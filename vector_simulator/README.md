# Overview
This directory contains the testing framework for the vector core. A generation script parses the vector instructions and generates the decoded information that a scalar core would produce. Then, the vector driver compiles this information and drives it to the vector datapath.

The top file of the testbench is the `vector_sim_top.sv`. It instantiates the full vector core with the vector driver connected to it. It also includes some extra functionality, such as deadlock detection and performance printing on the test completion.

The top file of the tb driver is the `vector_driver.sv`. Internally it stores the instructions in program order by maintaining their decoded information in fifos. Each fifo has a different control information, that would have been generated by the decoders in the scalar pipeline. All this information is pieced together and pushed to the vector core via a ready/valid protocol. On top of that, the fifos can contain special encodings to trigger extra functionality. The main usage of this is to insert bubble cycles, where the scalar core would not push any vector instructions. This can happen on the end of vector loops, where the scalar core would execute some scalar code to determine if the computation has finished, and if not, update pointers and branch. During that time no vector instructions would/are pushed in the vector core. The fifos are populated reading memory files generated by an emulation script.

The emulation script is the `sim_generator.py`. It reads the vector instructions in a pseudo-assembly notation from a *.csv*, takes as a parameter the pipeline size and the application vector length (_AVL_) and computes the scalar decoder's outputs. For example, for a 1-lane pipeline, with application vector length == 10, and no hardware loop unrolling, the script would generate 10 loops, each containing the decoded information from the vector instructions, with bubble cycles between each loop emualating the control cycles of the scalar core. The output is stored in the `/decoder_results` directory, from where the testbench will read them.

_**Script Parameters:**_
- *parameter 1*: csv file path/name
- *parameter 2*: total elements to be processed (AVL)
- *parameter 3*: available vector lanes

```
python .\sim_generator.py .\instrs.csv AVL VECTOR_LANES
```

The number of the bubble cycles added for each loop iteration can be configured using the `TOTAL_BUBBLE_CYCLES` parameter inside the script. To extract meaningful performance metrics, the number of bubble cycles has to match the number of scalar instructions that the vector loop would normally use.

For example, to run the **vvadd** test from the provided examples:
- copy the `/vector_simulator/examples/vvadd/instrs.csv` file into the `/vector_simulator` directory
- run the generator: `python .\sim_generator.py .\instrs.csv 5000 8`
- open Questasim and navigate into the `/vector_simulator` directory
- execute `do compile_vector_simulator.do` in Questasim. The RTL will be built, the simulation will run and a pre-loaded waveform will be loaded at the end of the simulation. Some performance metrics will be saved in `/vector_simulator/perf_results/results.log`
